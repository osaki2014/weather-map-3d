<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>等圧線描画</title>
  <style>
    body { margin: 0; overflow: hidden; background: #fff; }
    canvas { display: block; }
    #slider-container {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 10px;
      background: rgba(255,255,255,0.8);
      border-radius: 8px;
      font-family: sans-serif;
    }
  </style>
  <!-- CDNで読み込み -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/svg-path-properties@1.1.0/dist/svg-path-properties.min.js"></script>
</head>
<body>
  <div id="slider-container">
    等圧線Z倍率：
    <input type="range" id="zSlider" min="0" max="5" value="1" step="0.1" />
    <span id="zValue">1.0</span>
  </div>
  <script>
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({antialias: true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    camera.position.z = 200;

    const material = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const group = new THREE.Group();
    scene.add(group);

    const zSlider = document.getElementById("zSlider");
    const zValue = document.getElementById("zValue");

    zSlider.addEventListener("input", () => {
      const z = parseFloat(zSlider.value);
      zValue.textContent = z.toFixed(1);
      updateLines(z);
    });

    let originalZ = 1;
    function updateLines(z) {
      group.children.forEach(line => {
        line.scale.z = z / originalZ;
      });
      originalZ = z;
    }

    fetch("SPAS_MONO_202506021800.svg")
      .then(res => res.text())
      .then(svgText => {
        const parser = new DOMParser();
        const svgDoc = parser.parseFromString(svgText, "image/svg+xml");
        const paths = svgDoc.querySelectorAll("path");
        paths.forEach(path => {
          const d = path.getAttribute("d");
          if (!d) return;
          const properties = new SVGPathProperties(d);
          const length = properties.getTotalLength();
          const points = [];
          for (let i = 0; i < length; i += 2) {
            const { x, y } = properties.getPointAtLength(i);
            points.push(new THREE.Vector3(x - 512, -(y - 512), 0));
          }
          const geometry = new THREE.BufferGeometry().setFromPoints(points);
          const line = new THREE.Line(geometry, material);
          group.add(line);
        });
      });

    function animate() {
      requestAnimationFrame(animate);
      group.rotation.z += 0.001;
      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
